Index: ../2_1/.idea/2_1.iml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/../2_1/.idea/2_1.iml b/../2_1/.idea/2_1.iml
new file mode 100644
--- /dev/null	(date 1640234991758)
+++ b/../2_1/.idea/2_1.iml	(date 1640234991758)
@@ -0,0 +1,2 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<module classpath="CMake" type="CPP_MODULE" version="4" />
\ No newline at end of file
Index: ../2_1/main.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//https://contest.yandex.ru/contest/32613/run-report/61100252/\r\n#include <iostream>\r\n#include <queue>\r\n\r\nstruct Node_BS {\r\n    int Key;\r\n    Node_BS* Left;\r\n    Node_BS* Right;\r\n\r\n    explicit Node_BS(int key) : Key(key), Left(nullptr), Right(nullptr) {}\r\n};\r\n\r\nvoid add_bst(int key, Node_BS* &node) {\r\n    std::queue<Node_BS*> stack_node;\r\n    stack_node.push(node);\r\n    while (!stack_node.empty()) {\r\n        Node_BS* node_ = stack_node.front();\r\n        if (key < node_->Key) {\r\n            if (node_->Left) {\r\n                stack_node.pop();\r\n                stack_node.push(node_->Left);\r\n            } else {\r\n                node_->Left = new Node_BS(key);\r\n                stack_node.pop();\r\n            }\r\n        } else {\r\n            stack_node.pop();\r\n            if (node_->Right) {\r\n                stack_node.push(node_->Right);\r\n            } else {\r\n                node_->Right = new Node_BS(key);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nint max_depth(Node_BS* node) {\r\n    if (node == nullptr) return 0;\r\n    return std::max(max_depth(node->Left), max_depth(node->Right)) + 1;\r\n}\r\n\r\nvoid FreeTree(Node_BS* node) {\r\n    std::queue <Node_BS*> stack_node;\r\n    stack_node.push(node);\r\n    while (!stack_node.empty()) {\r\n        Node_BS *aboba = stack_node.front();\r\n        stack_node.pop();\r\n        if (aboba != nullptr) {\r\n            stack_node.push(aboba->Left);\r\n            stack_node.push(aboba->Right);\r\n            delete aboba;\r\n        }\r\n    }\r\n}\r\n\r\nstruct Node_Treap {\r\n    int Key;\r\n    int Priority;\r\n    Node_Treap* Left;\r\n    Node_Treap* Right;\r\n    \r\n    explicit Node_Treap(int key, int priority) : Key(key), Priority(priority), Left(nullptr), Right(nullptr) {}\r\n};\r\n\r\nstd::pair<Node_Treap*, Node_Treap*> Split(Node_Treap* node, int key) {\r\n    if (node == nullptr) return {nullptr, nullptr};\r\n    if (key < node->Key) {\r\n        std::pair<Node_Treap*, Node_Treap*> p = Split(node->Left, key);\r\n        node->Left = p.second;\r\n        return {p.first, node};\r\n    } else {\r\n        auto [first, second] = Split(node->Right, key);\r\n        node->Right = first;\r\n        return {node, second};\r\n    }\r\n}\r\n\r\nNode_Treap* Merge(Node_Treap* left, Node_Treap* right) {\r\n    if (left == nullptr || right == nullptr) {\r\n        return left == nullptr ? right: left;\r\n    }\r\n    if (left->Priority > right->Priority) {\r\n        left->Right = Merge(left->Right, right);\r\n        return left;\r\n    } else {\r\n        right->Left = Merge(left, right->Left);\r\n        return right;\r\n    }\r\n}\r\n\r\nvoid add_treap(Node_Treap* &treap, int key, int priority) {\r\n    auto* new_node = new Node_Treap(key, priority);\r\n    auto [first, second] = Split(treap, key);\r\n    treap = Merge(Merge(first, new_node), second);\r\n}\r\n\r\nint max_depth(Node_Treap* node) {\r\n    if (node == nullptr) return 0;\r\n    return std::max(max_depth(node->Left), max_depth(node->Right)) + 1;\r\n}\r\n\r\nvoid FreeTree(Node_Treap* node) {\r\n    std::queue <Node_Treap*> stack_node;\r\n    stack_node.push(node);\r\n    while (!stack_node.empty()) {\r\n        Node_Treap *aboba = stack_node.front();\r\n        stack_node.pop();\r\n        if (aboba != nullptr) {\r\n            stack_node.push(aboba->Left);\r\n            stack_node.push(aboba->Right);\r\n            delete aboba;\r\n        }\r\n    }\r\n}\r\n\r\n\r\nint main() {\r\n    int n;\r\n    int x, y;\r\n    std::cin >> n;\r\n    std::cin >> x >> y;\r\n    auto* bst = new Node_BS(x);\r\n    auto* treap = new Node_Treap(x, y);\r\n\r\n    for (int i = 0; i < n - 1; i++) {\r\n        std::cin >> x >> y;\r\n        add_bst(x, bst);\r\n        add_treap(treap, x, y);\r\n    }\r\n    std::cout << abs(max_depth(bst) - max_depth(treap)) << std::endl;\r\n    FreeTree(bst);\r\n    FreeTree(treap);\r\n    return 0;\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/../2_1/main.cpp b/../2_1/main.cpp
--- a/../2_1/main.cpp	(revision de6b0f2dd75c039fa7eab06c8ede83778ee14170)
+++ b/../2_1/main.cpp	(date 1640234991723)
@@ -15,16 +15,14 @@
     stack_node.push(node);
     while (!stack_node.empty()) {
         Node_BS* node_ = stack_node.front();
+        stack_node.pop();
         if (key < node_->Key) {
             if (node_->Left) {
-                stack_node.pop();
                 stack_node.push(node_->Left);
             } else {
                 node_->Left = new Node_BS(key);
-                stack_node.pop();
             }
         } else {
-            stack_node.pop();
             if (node_->Right) {
                 stack_node.push(node_->Right);
             } else {
@@ -40,14 +38,14 @@
 }
 
 void FreeTree(Node_BS* node) {
-    std::queue <Node_BS*> stack_node;
-    stack_node.push(node);
-    while (!stack_node.empty()) {
-        Node_BS *aboba = stack_node.front();
-        stack_node.pop();
+    std::queue <Node_BS*> queue_node;
+    queue_node.push(node);
+    while (!queue_node.empty()) {
+        Node_BS *aboba = queue_node.front();
+        queue_node.pop();
         if (aboba != nullptr) {
-            stack_node.push(aboba->Left);
-            stack_node.push(aboba->Right);
+            queue_node.push(aboba->Left);
+            queue_node.push(aboba->Right);
             delete aboba;
         }
     }
